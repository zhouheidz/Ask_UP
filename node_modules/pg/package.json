{
  "_args": [
    [
      {
        "raw": "pg",
        "scope": null,
        "escapedName": "pg",
        "name": "pg",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\Munic\\Desktop\\hackathon"
    ]
  ],
  "_from": "pg@latest",
  "_id": "pg@6.2.3",
  "_inCache": true,
  "_location": "/pg",
  "_nodeVersion": "6.10.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/pg-6.2.3.tgz_1495634736291_0.0012075251433998346"
  },
  "_npmUser": {
    "name": "brianc",
    "email": "brian.m.carlson@gmail.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "pg",
    "scope": null,
    "escapedName": "pg",
    "name": "pg",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/pg/-/pg-6.2.3.tgz",
  "_shasum": "8988b7c69a1875a997d73b92036c42590b5f8024",
  "_shrinkwrap": null,
  "_spec": "pg",
  "_where": "C:\\Users\\Munic\\Desktop\\hackathon",
  "author": {
    "name": "Brian Carlson",
    "email": "brian.m.carlson@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/brianc/node-postgres/issues"
  },
  "dependencies": {
    "buffer-writer": "1.0.1",
    "packet-reader": "0.3.1",
    "pg-connection-string": "0.1.3",
    "pg-pool": "1.*",
    "pg-types": "1.*",
    "pgpass": "1.x",
    "semver": "4.3.2"
  },
  "description": "PostgreSQL client - pure javascript & libpq with the same API",
  "devDependencies": {
    "async": "0.9.0",
    "co": "4.6.0",
    "jshint": "2.5.2",
    "lodash": "4.13.1",
    "pg-copy-streams": "0.3.0",
    "promise-polyfill": "5.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "8988b7c69a1875a997d73b92036c42590b5f8024",
    "tarball": "https://registry.npmjs.org/pg/-/pg-6.2.3.tgz"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "gitHead": "3757ff7300f03798ee1865f1eaf7125abe9cbda4",
  "homepage": "http://github.com/brianc/node-postgres",
  "keywords": [
    "postgres",
    "pg",
    "libpq",
    "postgre",
    "database",
    "rdbms"
  ],
  "license": "MIT",
  "main": "./lib",
  "maintainers": [
    {
      "name": "brianc",
      "email": "brian.m.carlson@gmail.com"
    }
  ],
  "minNativeVersion": "1.7.0",
  "name": "pg",
  "optionalDependencies": {},
  "readme": "# node-postgres\n\n[![Build Status](https://secure.travis-ci.org/brianc/node-postgres.svg?branch=master)](http://travis-ci.org/brianc/node-postgres)\n[![Dependency Status](https://david-dm.org/brianc/node-postgres.svg)](https://david-dm.org/brianc/node-postgres)\n<span class=\"badge-npmversion\"><a href=\"https://npmjs.org/package/pg\" title=\"View this project on NPM\"><img src=\"https://img.shields.io/npm/v/pg.svg\" alt=\"NPM version\" /></a></span>\n<span class=\"badge-npmdownloads\"><a href=\"https://npmjs.org/package/pg\" title=\"View this project on NPM\"><img src=\"https://img.shields.io/npm/dm/pg.svg\" alt=\"NPM downloads\" /></a></span>\n\nNon-blocking PostgreSQL client for node.js.  Pure JavaScript and optional native libpq bindings.\n\n## Install\n\n```sh\n$ npm install pg\n```\n\n## Intro & Examples\n\nThere are 3 ways of executing queries\n\n1. Passing the query to a pool\n2. Borrowing a client from a pool and executing the query with it\n3. Obtaining an exclusive client and executing the query with it\n\nIt is recommended to pass the query to a pool as often as possible. If that isn't possible, because of long and complex transactions for example, borrow a client from a pool. Just remember to initialize the pool only once in your code so you maximize reusability of connections.\n\n### Why pooling?\n\nIf you're working on something like a web application which makes frequent queries you'll want to access the PostgreSQL server through a pool of clients.  Why?  For one thing, there is ~20-30 millisecond delay (YMMV) when connecting a new client to the PostgreSQL server because of the startup handshake.  Furthermore, PostgreSQL can support only a limited number of clients...it depends on the amount of ram on your database server, but generally more than 100 clients at a time is a __very bad thing__. :tm: Additionally, PostgreSQL can only execute 1 query at a time per connected client, so pipelining all queries for all requests through a single, long-lived client will likely introduce a bottleneck into your application if you need high concurrency.\n\nWith that in mind we can imagine a situation where you have a web server which connects and disconnects a new client for every web request or every query (don't do this!).  If you get only 1 request at a time everything will seem to work fine, though it will be a touch slower due to the connection overhead. Once you get >100 simultaneous requests your web server will attempt to open 100 connections to the PostgreSQL backend and :boom: you'll run out of memory on the PostgreSQL server, your database will become unresponsive, your app will seem to hang, and everything will break. Boooo!\n\n__Good news__: node-postgres ships with built in client pooling.  Client pooling allows your application to use a pool of already connected clients and reuse them for each request to your application.  If your app needs to make more queries than there are available clients in the pool the queries will queue instead of overwhelming your database & causing a cascading failure. :thumbsup:\n\nnode-postgres uses [pg-pool](https://github.com/brianc/node-pg-pool.git) to manage pooling. It bundles it and exports it for convenience.  If you want, you can `require('pg-pool')` and use it directly - it's the same as the constructor exported at `pg.Pool`.\n\nIt's __highly recommended__ you read the documentation for [pg-pool](https://github.com/brianc/node-pg-pool.git).\n\n[Here is an up & running quickly example](https://github.com/brianc/node-postgres/wiki/Example)\n\nFor more information about `config.ssl` check [TLS (SSL) of nodejs](https://nodejs.org/dist/latest-v4.x/docs/api/tls.html)\n\n### Pooling example\n\nLet's create a pool in `./lib/db.js` which will be reused across the whole project\n\n```javascript\nconst pg = require('pg');\n\n// create a config to configure both pooling behavior\n// and client options\n// note: all config is optional and the environment variables\n// will be read if the config is not present\nvar config = {\n  user: 'foo', //env var: PGUSER\n  database: 'my_db', //env var: PGDATABASE\n  password: 'secret', //env var: PGPASSWORD\n  host: 'localhost', // Server hosting the postgres database\n  port: 5432, //env var: PGPORT\n  max: 10, // max number of clients in the pool\n  idleTimeoutMillis: 30000, // how long a client is allowed to remain idle before being closed\n};\n\n//this initializes a connection pool\n//it will keep idle connections open for 30 seconds\n//and set a limit of maximum 10 idle clients\nconst pool = new pg.Pool(config);\n\npool.on('error', function (err, client) {\n  // if an error is encountered by a client while it sits idle in the pool\n  // the pool itself will emit an error event with both the error and\n  // the client which emitted the original error\n  // this is a rare occurrence but can happen if there is a network partition\n  // between your application and the database, the database restarts, etc.\n  // and so you might want to handle it and at least log it out\n  console.error('idle client error', err.message, err.stack);\n});\n\n//export the query method for passing queries to the pool\nmodule.exports.query = function (text, values, callback) {\n  console.log('query:', text, values);\n  return pool.query(text, values, callback);\n};\n\n// the pool also supports checking out a client for\n// multiple operations, such as a transaction\nmodule.exports.connect = function (callback) {\n  return pool.connect(callback);\n};\n```\n\nNow if in `./foo.js` you want to pass a query to the pool\n\n```js\nconst pool = require('./lib/db');\n\n//to run a query we just pass it to the pool\n//after we're done nothing has to be taken care of\n//we don't have to return any client to the pool or close a connection\npool.query('SELECT $1::int AS number', ['2'], function(err, res) {\n  if(err) {\n    return console.error('error running query', err);\n  }\n\n  console.log('number:', res.rows[0].number);\n});\n```\n\nOr if in `./bar.js` you want borrow a client from the pool\n\n```js\nconst pool = require('./lib/db');\n\n//ask for a client from the pool\npool.connect(function(err, client, done) {\n  if(err) {\n    return console.error('error fetching client from pool', err);\n  }\n  \n  //use the client for executing the query\n  client.query('SELECT $1::int AS number', ['1'], function(err, result) {\n    //call `done(err)` to release the client back to the pool (or destroy it if there is an error)\n    done(err);\n\n    if(err) {\n      return console.error('error running query', err);\n    }\n    console.log(result.rows[0].number);\n    //output: 1\n  });\n});\n```\n\nFor more examples, including how to use a connection pool with promises and async/await see the [example](https://github.com/brianc/node-postgres/wiki/Example) page in the wiki.\n\n### Obtaining an exclusive client, example\n\n```js\nvar pg = require('pg');\n\n// instantiate a new client\n// the client will read connection information from\n// the same environment variables used by postgres cli tools\nvar client = new pg.Client();\n\n// connect to our database\nclient.connect(function (err) {\n  if (err) throw err;\n\n  // execute a query on our database\n  client.query('SELECT $1::text as name', ['brianc'], function (err, result) {\n    if (err) throw err;\n\n    // just print the result to the console\n    console.log(result.rows[0]); // outputs: { name: 'brianc' }\n\n    // disconnect the client\n    client.end(function (err) {\n      if (err) throw err;\n    });\n  });\n});\n\n```\n\n## [More Documentation](https://github.com/brianc/node-postgres/wiki)\n\n## Native Bindings\n\nTo install the [native bindings](https://github.com/brianc/node-pg-native.git):\n\n```sh\n$ npm install pg pg-native\n```\n\n\nnode-postgres contains a pure JavaScript protocol implementation which is quite fast, but you can optionally use [native](https://github.com/brianc/node-pg-native) [bindings](https://github.com/brianc/node-libpq) for a 20-30% increase in parsing speed (YMMV). Both versions are adequate for production workloads. I personally use the pure JavaScript implementation because I like knowing what's going on all the way down to the binary on the socket, and it allows for some fancier [use](https://github.com/brianc/node-pg-cursor) [cases](https://github.com/brianc/node-pg-query-stream) which are difficult to do with libpq. :smile:\n\nTo use the native bindings, first install [pg-native](https://github.com/brianc/node-pg-native.git).  Once pg-native is installed, simply replace `var pg = require('pg')` with `var pg = require('pg').native`.  Make sure any exported constructors from `pg` are from the native instance.  Example:\n\n```js\nvar pg = require('pg').native\nvar Pool = require('pg').Pool // bad! this is not bound to the native client\nvar Client = require('pg').Client // bad! this is the pure JavaScript client\n\nvar pg = require('pg').native\nvar Pool = pg.Pool // good! a pool bound to the native client\nvar Client = pg.Client // good! this client uses libpq bindings\n```\n\n#### API differences\n\nnode-postgres abstracts over the pg-native module to provide the same interface as the pure JavaScript version. Care has been taken to keep the number of api differences between the two modules to a minimum.  \nHowever, currently some differences remain, especially :\n* the error object in pg-native is different : notably, the information about the postgres error code is not present in field `code` but in the field `sqlState` , and the name of a few other fields is different (see https://github.com/brianc/node-postgres/issues/938, https://github.com/brianc/node-postgres/issues/972).\nSo for example, if you rely on error.code in your application, your will have to adapt your code to work with native bindings.\n* the notification object has a few less properties  (see https://github.com/brianc/node-postgres/issues/1045)\n* column objects have less properties (see https://github.com/brianc/node-postgres/issues/988)\n* the modules https://github.com/brianc/node-pg-copy-streams and https://github.com/brianc/node-pg-query-stream do not work with native bindings (you will have to require 'pg' to use them).\n\nThus, it is recommended you use either the pure JavaScript or native bindings in both development and production and don't mix & match them in the same process - it can get confusing!\n\n## Features\n\n* pure JavaScript client and native libpq bindings share _the same api_\n* connection pooling\n* extensible js<->postgresql data-type coercion\n* supported PostgreSQL features\n  * parameterized queries\n  * named statements with query plan caching\n  * async notifications with `LISTEN/NOTIFY`\n  * bulk import & export with `COPY TO/COPY FROM`\n\n## Extras\n\nnode-postgres is by design pretty light on abstractions.  These are some handy modules we've been using over the years to complete the picture.\nEntire list can be found on [wiki](https://github.com/brianc/node-postgres/wiki/Extras)\n\n## Contributing\n\n__:heart: contributions!__\n\nIf you need help getting the tests running locally or have any questions about the code when working on a patch please feel free to email me or gchat me.\n\nI will __happily__ accept your pull request if it:\n- __has tests__\n- looks reasonable\n- does not break backwards compatibility\n\nInformation about the testing processes is in the [wiki](https://github.com/brianc/node-postgres/wiki/Testing).\n\nOpen source belongs to all of us, and we're all invited to participate!\n\n## Troubleshooting and FAQ\n\nThe causes and solutions to common errors can be found among the [Frequently Asked Questions(FAQ)](https://github.com/brianc/node-postgres/wiki/FAQ)\n\n## Support\n\nIf at all possible when you open an issue please provide\n- version of node\n- version of postgres\n- smallest possible snippet of code to reproduce the problem\n\nUsually I'll pop the code into the repo as a test.  Hopefully the test fails.  Then I make the test pass.  Then everyone's happy!\n\nIf you need help or run into _any_ issues getting node-postgres to work on your system please report a bug or contact me directly.  I am usually available via google-talk at my github account public email address.  Remember this is a labor of love, and though I try to get back to everything sometimes life takes priority, and I might take a while.  It helps if you use nice code formatting in your issue, search for existing answers before posting, and come back and close out the issue if you figure out a solution.  The easier you can make it for me, the quicker I'll try and respond to you!\n\nIf you need deeper support, have application specific questions, would like to sponsor development, or want consulting around node & postgres please send me an email, I'm always happy to discuss!\n\nI usually tweet about any important status updates or changes to node-postgres on twitter.\nFollow me [@briancarlson](https://twitter.com/briancarlson) to keep up to date.\n\n\n## License\n\nCopyright (c) 2010-2017 Brian Carlson (brian.m.carlson@gmail.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianc/node-postgres.git"
  },
  "scripts": {
    "changelog": "npm i github-changes && ./node_modules/.bin/github-changes -o brianc -r node-postgres -d pulls -a -v",
    "test": "make test-all connectionString=postgres://postgres@localhost:5432/postgres"
  },
  "version": "6.2.3"
}
